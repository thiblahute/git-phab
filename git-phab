#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# PYTHON_ARGCOMPLETE_OK
#
# git-phab - git subcommand to integrate with phabricator
#
# Copyright (C) 2008  Owen Taylor
# Copyright (C) 2015  Xavier Claessens <xavier.claessens@collabora.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, If not, see
# http://www.gnu.org/licenses/.

import tempfile
import subprocess
import argparse
import argcomplete
import git
import os
import re
import sys
import json
from urllib.parse import urlsplit, urlunsplit


class GitPhab:
    def __init__(self):
        self.task = None
        self.remote = None

    def read_arcconfig(self):
        path = os.path.join(self.repo.working_tree_dir, '.arcconfig')
        with open(path) as f:
            self.arcconfig = json.load(f)

        try:
            self.phabricator_uri = self.arcconfig["phabricator.uri"]
            self.project = self.arcconfig["project"]
        except KeyError as e:
            die("Could not find '%s' in .arcconfig.\n"
                "Make sure the current repository is properly configured "
                "for phabricator" % e.args[0])

        # Remove trailing '/' if any
        if self.phabricator_uri[-1] == '/':
            self.phabricator_uri = self.phabricator_uri[:-1]

        reply = conduit("project.query", {"names": [self.project]})
        phids = [phid for phid in reply["response"]["data"].keys()]
        if len(phids) != 1:
            die("Couldn't find phid for project '%s'" % self.project)
        self.project_phid = phids[0]

    # Copied from git-bz
    def prompt(self, message):
        try:
            while True:
                # Using print here could result in Python adding a stray space
                # before the next print
                sys.stdout.write(message + " [yn] ")
                sys.stdout.flush()
                line = sys.stdin.readline().strip()
                if line == 'y' or line == 'Y':
                    return True
                elif line == 'n' or line == 'N':
                    return False
        except KeyboardInterrupt:
            # Ctrl+C doesn’t cause a newline
            sys.stdout.write("\n")
            return False

    # Copied from git-bz
    def edit_file(self, filename):
        editor = self.repo.git.var("GIT_EDITOR")
        process = subprocess.Popen(editor + " " + filename, shell=True)
        process.wait()
        if process.returncode != 0:
            die("Editor exited with non-zero return code")

    # Copied from git-bz
    def edit_template(self, template):
        # Prompts the user to edit the text 'template' and returns list of
        # lines with comments stripped

        handle, filename = tempfile.mkstemp(".txt", "git-phab-")
        f = os.fdopen(handle, "w")
        f.write(template)
        f.close()

        self.edit_file(filename)

        with open(filename, 'r') as f:
            return [l for l in f.readlines() if not l.startswith("#")]

    def create_task(self):
        task_infos = None
        while not task_infos:
            task_infos = self.edit_template(
                "\n"
                "# Merge branch: %s\n"
                "# Please enter a task title and description for the merge "
                "request" % self.repo.active_branch.name)

        description = ""
        title = task_infos[0]
        if len(task_infos) > 1:
            description = '\n'.join(task_infos[1:])

        reply = conduit("maniphest.createtask", {
            "title": title,
            "description": description,
            "projectPHIDs": [self.project_phid],
        })

        return reply

    def task_from_branchname(self, bname):
        m = re.search('(^T[0-9]+)($|-.*)', bname)
        return m.group(1) if m else None


# Copied from git-bz
def die(message):
    print(message, file=sys.stderr)
    sys.exit(1)


def get_commits(commit_or_revision_range):
    try:
        # See if the argument identifies a single revision
        commits = [args.repo.rev_parse(commit_or_revision_range)]
    except:
        # If not, assume the argument is a range
        try:
            commits = list(args.repo.iter_commits(commit_or_revision_range))
        except:
            # If not again, the argument must be invalid — perhaps the user has
            # accidentally specified a bug number but not a revision.
            commits = []

    if len(commits) == 0:
        die(("'%s' does not name any commits. Use HEAD to specify just the "
             "last commit") % commit_or_revision_range)

    return commits


def get_differential_link(commit):
    m = re.search('(^Differential Revision: )(.*)$',
                  commit.message, re.MULTILINE)
    return None if m is None else m.group(2)


def format_commit(commit):
    link = get_differential_link(commit)
    d = "N/A" if link is None else link[link.rfind('/') + 1:]
    return u"%s %s — %s" % (commit.hexsha[:7], d, commit.summary)


def print_commit(commit):
    print(format_commit(commit))


def conduit(cmd, args):
    output = subprocess.check_output('arc call-conduit ' + cmd,
                                     input=bytes(json.dumps(args), 'utf-8'),
                                     shell=True)
    return json.loads(output.decode('utf-8'))


def get_wip_branch(args):
    return "wip/phab/" + args.task


def validate_args(args):
    args.repo = git.Repo(os.getcwd(), search_parent_directories=True)
    args.read_arcconfig()

    # Ensure user has setup git-phab before first usage
    try:
        config_remote = args.repo.config_reader().get_value('phab', 'remote')
    except:
        die("** Please configure git-phab before first usage.\n\n"
            " - Set the remote to be used to push your branches for review "
            "(e.g. 'origin').\n"
            "       git config phab.remote <remote>\n")

    args.remote_from_config = False
    if not args.remote:
        args.remote = config_remote
        args.remote_from_config = True

    # Validate that args.remote exists
    try:
        remote = args.repo.remote(args.remote)
    except:
        die("%s not a valid remote. Aborting." % args.remote)

    # Make sure the user knows what he's doing if the remote's fetch URL is
    # using ssh, otherwise reviewers might not be able to pull their branch.
    url = urlsplit(remote.config_reader.get('url'))
    if url.scheme in ["ssh", "git+ssh"]:
        try:
            force_ssh = \
                args.repo.config_reader().get_value('phab', 'force-ssh-remote')
        except:
            force_ssh = False

        if not force_ssh:
            if args.prompt("The configured phab.remote (%s) is using ssh.\n"
                           "It means it might not be readable by some people."
                           "\nAre you sure you want to continue?"
                           % args.remote):
                writer = args.repo.config_writer()
                writer.set_value('phab', 'force-ssh-remote', True)
                writer.release()
            else:
                pushurl = urlunsplit(url)
                fetchurl = urlunsplit(url._replace(scheme='git'))
                die("To reconfigure your remote, run:\n"
                    "  git remote set-url {0} {1}\n"
                    "  git remote set-url --push {0} {2}"
                    .format(args.remote, fetchurl, pushurl))

    # Try to guess the task from branch name
    args.branch_task = args.task_from_branchname(str(args.repo.head.reference))

    if not args.task:
        args.task = args.branch_task

    # Validate the args.task is in the right format
    if args.task and not re.fullmatch('T[0-9]+', args.task):
        die(("Task '%s' is not in the correct format. "
             "Expecting 'T123'." % args.task))


def parse_commit_msg(msg):
    subject = None
    body = []
    fields = []

    for line in msg.split('\n'):
        if not subject:
            subject = line
        elif line.startswith('Differential Revision: '):
            fields.append(line)
        else:
            body.append(line)

    return subject, body, fields


def do_attach(args):
    if args.repo.is_dirty():
        die("Repository is dirty. Aborting.")

    # If we are in branch "T123" and user does "git phab attach -t T456",
    # that's suspicious. Better stop before doing a mistake.
    if args.branch_task and args.branch_task != args.task:
        die("Your current branch name suggests task %s but you're going to "
            "attach to task %s. Aborting." % (args.branch_task, args.task))

    summary = ""

    # Oldest commit is last in the list
    commits = get_commits(args.revision_range)
    all_commits = list(args.repo.iter_commits(commits[-1].hexsha + "^..HEAD"))

    # Sanity checks
    for c in commits:
        if c not in all_commits:
            die("'%s' is not in current tree. Aborting." % c.hexsha)
        if len(c.parents) > 1:
            die("'%s' is a merge commit. Aborting." % c.hexsha)

    # Ask confirmation before doing any harm
    for c in commits:
        print_commit(c)

    if not args.task:
        if args.prompt("Create a task for above commits?"):
            try:
                args.task = args.create_task()["response"]["objectName"]
                summary += "New: task %s\n" % args.task
            except KeyError:
                die("Could not create task.")

    if not args.prompt("Attach above commits?" if not args.task else
                       "Attach above commits to task %s?" % args.task):
        print("Aborting")
        sys.exit(0)

    orig_commit = args.repo.head.commit
    orig_branch = args.repo.head.reference

    options = ['--allow-untracked',
               '--config history.immutable=false',
               '--verbatim']
    if args.reviewers:
        options.append('--reviewers ' + args.reviewers)
    if args.message:
        options.append('--message "' + args.message + '"')
    arc_cmd = 'arc diff %s HEAD~1' % (' '.join(options))

    try:
        # Detach HEAD from the branch; this gives a cleaner reflog for the
        # branch
        print("Moving to starting point")
        args.repo.head.reference = commits[-1].parents[0]
        args.repo.head.reset(index=True, working_tree=True)

        last_revision_id = None
        for commit in reversed(all_commits):
            args.repo.git.cherry_pick(commit.hexsha)

            if commit in commits:
                # Add extra info in the commit msg. It is important that
                # phabricator fields are last, after all common git fields like
                # 'Reviewed-by:', etc. Note that "Depends on" is not a field
                # and is parsed from the body part.
                subject, body, fields = parse_commit_msg(commit.message)
                if last_revision_id:
                    body.append("Depends on %s" % last_revision_id)
                if args.task:
                    fields.append("Maniphest Tasks: %s" % args.task)
                fields.append("Projects: %s" % args.project_phid)

                msg = '\n\n'.join([subject,
                                   '\n'.join(body),
                                   '\n'.join(fields)])

                args.repo.head.commit = args.repo.head.commit.parents[0]
                args.repo.head.commit = args.repo.index.commit(msg)

                print("attach " + commit.hexsha)
                try:
                    subprocess.check_call(arc_cmd, shell=True)
                except:
                    print("Command '%s' failed. Continuing." % arc_cmd)
                    summary += "Failed: %s\n" % format_commit(commit)
                    args.repo.head.commit = commit
                    continue

                # arc diff modified our commit message. Re-commit it with the
                # original message, adding only the "Differential Revision:"
                # line.
                msg = commit.message
                orig_link = get_differential_link(commit)
                new_link = get_differential_link(args.repo.head.commit)
                if orig_link is None and new_link is not None:
                    msg = msg + '\nDifferential Revision: ' + new_link
                    summary += "New: "
                else:
                    summary += "Updated: "

                args.repo.head.commit = args.repo.head.commit.parents[0]
                args.repo.head.commit = args.repo.index.commit(msg)
                last_revision_id = new_link.split("/")[-1]

                summary += format_commit(args.repo.head.commit) + "\n"
            else:
                print("pick " + commit.hexsha)
                summary += "Picked: %s\n" % format_commit(commit)

        if orig_branch is not None:
            orig_branch.commit = args.repo.head.commit
            args.repo.head.reference = orig_branch
    except:
        print("Cleaning up back to original state on error")
        args.repo.head.commit = orig_commit
        if orig_branch is not None:
            orig_branch.commit = orig_commit
            args.repo.head.reference = orig_branch
        args.repo.head.reset(index=True, working_tree=True)
        raise

    if args.task:
        try:
            branch = get_wip_branch(args)
            remote = args.repo.remote(args.remote)
            if args.prompt('Push HEAD to %s/%s?' % (remote, branch)):
                remote.push('HEAD:refs/heads/' + branch, force=True)
                summary += "Branch pushed to %s/%s\n" % (remote, branch)

            uri = "%s#%s" % (remote.config_reader.get('url'), branch)
            try:
                conduit('maniphest.update', {
                    "id": int(args.task[1:]),
                    "auxiliary": {
                        "std:maniphest:git:uri-branch": uri
                    }
                })
            except:
                print("Failed to set std:maniphest:git:uri-branch to %s" % uri)

        except Exception as e:
            summary += "Failed: push wip branch: %s\n" % e

        if not args.branch_task:
            # Check if we already have a branch for this task
            branch = None
            for b in args.repo.branches:
                if args.task_from_branchname(b.name) == args.task:
                    branch = b
                    break

            if branch:
                if args.prompt('Reset branch %s to what has just been sent '
                               'to phabricator?' % branch.name):
                    branch.commit = args.repo.head.commit
                    summary += "Branch %s reset to %s" % \
                               (branch.name, branch.commit)
            else:
                cur_bname = str(args.repo.head.reference)
                new_bname = args.task
                if cur_bname not in ["master"]:
                    new_bname += '-' + cur_bname

                if args.prompt('Create a new branch called: %s?' % new_bname):
                    args.repo.create_head(new_bname)
                    summary += "Branch %s created" % new_bname

    print("\n\nSummary:")
    print(summary)


def do_log(args):
    commits = get_commits(args.revision_range)
    for c in commits:
        print_commit(c)


def do_fetch(args):
    branch = get_wip_branch(args)
    remote = args.remote

    if args.remote_from_config:
        try:
            reply = conduit('maniphest.query', {
                "ids": [int(args.task[1:])]
            })
            props = list(reply['response'].values())[0]
            uri = props['auxiliary']['std:maniphest:git:uri-branch']
            remote, branch = uri.split('#')
        except:
            print("Couldn't get git URI from Maniphest")

    print("Git URI: %s, branch: %s" % (remote, branch))
    args.repo.git.fetch(remote, "%s:%s" % (branch, args.task), force=True)
    print("Branch %s created." % args.task)


def do_browse(args):
    urls = []
    if not args.objects:
        if not args.task:
            die("Could not figure out a task from branch name")
        args.objects = [args.task]

    for obj in args.objects:
        if re.fullmatch('(T|D)[0-9]+', obj):
            urls.append(args.phabricator_uri + "/" + obj)
            continue

        try:
            commit = args.repo.rev_parse(obj)
        except git.BadName:
            die("Wrong commit hash: %s" % obj)

        uri = get_differential_link(commit)
        if not uri:
            print("Could not find a differential for %s" % obj)
            continue
        urls.append(uri)

    for url in urls:
        print("Openning: %s" % url)
        subprocess.check_call(["xdg-open", url],
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL)


def DisabledCompleter(prefix, **kwargs):
    return []


parser = argparse.ArgumentParser(description='Phabricator integration.')
subparsers = parser.add_subparsers()

attach_parser = subparsers.add_parser(
    'attach', help="Generate a Differential for each commit")
attach_parser.add_argument(
    '--reviewers', '-r', metavar='<username1,username2,...>',
    help="A list of reviewers") \
    .completer = DisabledCompleter
attach_parser.add_argument(
    '--message', '-m', metavar='<message>',
    help=("When updating a revision, use the specified message instead of "
          "prompting")) \
    .completer = DisabledCompleter
attach_parser.add_argument(
    '--task', '-t', metavar='<T123>',
    help=("Set the task this Differential refers to")) \
    .completer = DisabledCompleter
attach_parser.add_argument(
    '--remote', metavar='<remote>',
    help=("A remote repository to push to. "
          "Overrides 'phab.remote' configuration.")) \
    .completer = DisabledCompleter
attach_parser.add_argument(
    'revision_range', metavar='<revision range>',
    nargs='?', default='origin/master..',
    help="commit or revision range to attach (Default: 'origin/master..')") \
    .completer = DisabledCompleter
attach_parser.set_defaults(func=do_attach)

log_parser = subparsers.add_parser(
    'log', help="Show commit logs with their differential ID")
log_parser.add_argument(
    'revision_range', metavar='<revision range>',
    nargs='?', default='origin/master..',
    help="commit or revision range to show (Default: 'origin/master..')") \
    .completer = DisabledCompleter
log_parser.set_defaults(func=do_log)

fetch_parser = subparsers.add_parser(
    'fetch', help="Fetch a task's branch")
fetch_parser.add_argument(
    '--remote', metavar='<remote>',
    help=("A remote repository to fetch from. "
          "Overrides 'phab.remote' configuration.")) \
    .completer = DisabledCompleter
fetch_parser.add_argument(
    'task', metavar='<T123>',
    help="The task to fetch") \
    .completer = DisabledCompleter
fetch_parser.set_defaults(func=do_fetch)

browse_parser = subparsers.add_parser(
    'browse', help="Open the task of the current "
    "branch in web browser")
browse_parser.add_argument(
    'objects', nargs='*', default=[],
    help="The 'objects' to browse. It can either be a task ID, "
    "a revision ID, a commit hash or empty to open current branch's task.") \
    .completer = DisabledCompleter
browse_parser.set_defaults(func=do_browse)

obj = GitPhab()
argcomplete.autocomplete(parser)
args = parser.parse_args(namespace=obj)
validate_args(args)
args.func(args)
